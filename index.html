<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Attendly</title>
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.7.1/dist/chart.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@2.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.3.2/papaparse.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/hammerjs@2.0.8/hammer.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@1.2.1/dist/chartjs-plugin-zoom.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f8f9fa;
            color: #333;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1, h2, h3 {
            color: #2c3e50;
        }
        .upload-section {
            margin-bottom: 20px;
            padding: 15px;
            border: 1px dashed #ccc;
            border-radius: 5px;
            background-color: #f8f9fa;
        }
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 20px;
            padding: 15px;
            background-color: #f0f4f8;
            border-radius: 5px;
        }
        .control-group {
            flex: 1;
            min-width: 200px;
        }
        .chart-container {
            position: relative;
            height: 400px;
            margin-bottom: 30px;
        }
        .results-container {
            margin-top: 30px;
            padding: 15px;
            background-color: #f0f4f8;
            border-radius: 5px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }
        table, th, td {
            border: 1px solid #ddd;
        }
        th, td {
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #f2f2f2;
        }
        .tab-container {
            margin-top: 20px;
        }
        .tab-buttons {
            display: flex;
            gap: 5px;
            margin-bottom: 10px;
        }
        .tab-button {
            padding: 10px 15px;
            background-color: #e9ecef;
            border: none;
            border-radius: 5px 5px 0 0;
            cursor: pointer;
        }
        .tab-button.active {
            background-color: #007bff;
            color: white;
        }
        .tab-content {
            display: none;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 0 5px 5px 5px;
        }
        .tab-content.active {
            display: block;
        }
        .error {
            color: #dc3545;
            padding: 10px;
            background-color: #f8d7da;
            border-radius: 5px;
            margin-bottom: 15px;
        }
        .success {
            color: #28a745;
            padding: 10px;
            background-color: #d4edda;
            border-radius: 5px;
            margin-bottom: 15px;
        }
        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 5px;
        }
        button:hover {
            background-color: #0069d9;
        }
        .loading {
            display: none;
            text-align: center;
            margin: 20px 0;
        }
        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border-left-color: #007bff;
            animation: spin 1s linear infinite;
            display: inline-block;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        #debugInfo {
            margin-top: 20px;
            padding: 10px;
            background-color: #f8f9fa;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-family: monospace;
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
            display: none;
        }
        .form-group {
            margin-bottom: 10px;
        }
        .form-group label {
            display: block;
            margin-bottom: 5px;
        }
        .form-group select, .form-group input {
            width: 100%;
            padding: 6px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        .chart-actions {
            margin-bottom: 10px;
            text-align: right;
        }
        .download-btn {
            background-color: #28a745;
        }
        .download-btn:hover {
            background-color: #218838;
        }
        .reset-zoom-btn {
            background-color: #6c757d;
        }
        .reset-zoom-btn:hover {
            background-color: #5a6268;
        }
        .checkbox-group {
            margin-top: 10px;
        }
        .checkbox-group label {
            display: inline-block;
            margin-right: 10px;
        }
        .seasonal-chart {
            height: 250px;
            margin-top: 20px;
        }
        .coefficient-table {
            margin-top: 15px;
            max-height: 300px;
            overflow-y: auto;
        }
        #downloadStatus {
            margin-top: 10px;
            font-style: italic;
        }
    </style>
</head>
<body>
    <div class="container">
        <img type="image/svg+xml" src="favicon.svg">
        <h1>Attendly</h1>
        <p>Intelligent attendance insights for your church.</p>
        <p>This app was authored by Simon Angus (from <a href="https://cityonahill.com.au/melbourne-east">City on a Hill East</a> in Melbourne, Australia) and Claude 3.7 Sonnet, using <a href="sodalabs.io">Monash University SoDa Lab's</a> Assistant GPT AI system. Contact: <a href="mailto:simon.angus@monash.edu?Subject:Attendly">email Simon</a>.</p>
        
        <div class="upload-section">
            <h2>Upload Attendance Data</h2>
            <p>Upload a CSV file with attendance data. The file should include columns named <tt>Date</tt> (in DD/MM/YYYY format), <tt>Attendance_type</tt> ('Sunday services', 'City Kids'), <tt>Service_name</tt> ('AM_1', 'AM_2', etc.), <tt>Attendance</tt> (count, e.g. '71'), and <tt>AM_PM</tt> (morning/evening grouping, e.g. 'AM', 'PM'). This format follows City on a Hill's internal reporting style.</p>
            <input type="file" id="csvFile" accept=".csv">
            <button id="uploadBtn">Upload and Analyze</button>
            <div id="uploadStatus"></div>
            <div class="loading" id="loadingIndicator">
                <div class="spinner"></div>
                <p>Processing data...</p>
            </div>
            <!-- <div>
                <label><input type="checkbox" id="showDebug"> Show Debug Info</label>
            </div>
            <div id="debugInfo"></div> -->
        </div>
        
        <div id="analysisSection" style="display: none;">
            <div class="controls">
                <div class="control-group">
                    <h3>Visualization Options</h3>
                    <div class="form-group">
                        <label>View Type:</label>
                        <div>
                            <label><input type="radio" name="viewType" value="total" checked> Total Attendance by Date</label>
                        </div>
                        <div>
                            <label><input type="radio" name="viewType" value="ampm"> Split by AM/PM</label>
                        </div>
                        <div>
                            <label><input type="radio" name="viewType" value="type"> City Kids vs Sunday Services</label>
                        </div>
                    </div>
                </div>
                
                <div class="control-group">
                    <h3>Forecasting Options</h3>
                    <div class="form-group">
                        <label for="seriesSelector">Series to Forecast:</label>
                        <select id="seriesSelector">
                            <option value="total">Total Attendance</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="historyYears">Years of History to Use:</label>
                        <select id="historyYears">
                            <option value="all">All Available Data</option>
                            <option value="1">Last 1 Year</option>
                            <option value="2">Last 2 Years</option>
                            <option value="3">Last 3 Years</option>
                            <option value="5">Last 5 Years</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="forecastMonths">Forecast Months:</label>
                        <select id="forecastMonths">
                            <option value="6">6 months</option>
                            <option value="12" selected>12 months</option>
                            <option value="18">18 months</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="nowcastMonths">Nowcast Forecast Period:</label>
                        <select id="nowcastMonths">
                            <option value="3">Last 3 months</option>
                            <option value="6" selected>Last 6 months</option>
                            <option value="12">Last 12 months</option>
                        </select>
                    </div>
                    <div class="checkbox-group">
                        <label><input type="checkbox" id="useSeasonality" checked> Include Monthly Seasonality</label>
                    </div>
                    <div>
                        <button id="updateBtn">Update Analysis</button>
                    </div>
                </div>
            </div>
            
            <div class="tab-container">
                <div class="tab-buttons">
                    <button class="tab-button active" data-tab="visualization">Visualization</button>
                    <button class="tab-button" data-tab="forecast">Forecast</button>
                    <button class="tab-button" data-tab="nowcast">Nowcast</button>
                    <button class="tab-button" data-tab="model">Model Details</button>
                    <button class="tab-button" data-tab="seasonality">Seasonality</button>
                </div>
                
                <div id="visualization" class="tab-content active">
                    <h2>Attendance Visualization</h2>
                    <div class="chart-actions">
                        <button class="reset-zoom-btn" id="resetZoomVis">Reset Zoom</button>
                    </div>
                    <div class="chart-container">
                        <canvas id="attendanceChart"></canvas>
                    </div>
                </div>
                
                <div id="forecast" class="tab-content">
                    <h2>Attendance Forecast</h2>
                    <div class="chart-actions">
                        <button class="reset-zoom-btn" id="resetZoomForecast">Reset Zoom</button>
                    </div>
                    <div class="chart-container">
                        <canvas id="forecastChart"></canvas>
                    </div>
                    <div class="results-container">
                        <h3>Forecast Results</h3>
                        <div class="chart-actions">
                            <button class="download-btn" id="downloadForecastCSV">Download as CSV</button>
                            <div id="downloadStatus"></div>
                        </div>
                        <div id="forecastResults"></div>
                    </div>
                </div>
                
                <div id="nowcast" class="tab-content">
                    <h2>Attendance Nowcast</h2>
                    <div class="chart-actions">
                        <button class="reset-zoom-btn" id="resetZoomNowcast">Reset Zoom</button>
                    </div>
                    <div class="chart-container">
                        <canvas id="nowcastChart"></canvas>
                    </div>
                    <div class="results-container">
                        <h3>Nowcast Accuracy</h3>
                        <div class="chart-actions">
                            <button class="download-btn" id="downloadNowcastCSV">Download as CSV</button>
                        </div>
                        <div id="nowcastResults"></div>
                    </div>
                </div>
                
                <div id="model" class="tab-content">
                    <h2>Model Details</h2>
                    <div class="results-container">
                        <h3>Regression Model</h3>
                        <div class="chart-actions">
                            <button class="download-btn" id="downloadModelCSV">Download Model Details</button>
                        </div>
                        <div id="modelDetails"></div>
                    </div>
                </div>
                
                <div id="seasonality" class="tab-content">
                    <h2>Monthly Seasonality Effects</h2>
                    <div class="chart-actions">
                        <button class="download-btn" id="downloadSeasonalityCSV">Download Seasonality Data</button>
                    </div>
                    <div class="seasonal-chart">
                        <canvas id="seasonalityChart"></canvas>
                    </div>
                    <div class="results-container">
                        <h3>Monthly Effects</h3>
                        <div id="seasonalityDetails"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // All code MUST be wrapped in an async IIFE
        (async function() {
            try {
                // Global variables
                let attendanceData = [];
                let aggregatedData = [];
                let charts = {};
                let models = {};
                let forecastResults = null;
                let nowcastResults = null;
                let seasonalityResults = null;
                
                // Month names
                const monthNames = [
                    "January", "February", "March", "April", "May", "June",
                    "July", "August", "September", "October", "November", "December"
                ];
                
                // DOM elements
                const uploadBtn = document.getElementById('uploadBtn');
                const csvFileInput = document.getElementById('csvFile');
                const uploadStatus = document.getElementById('uploadStatus');
                const analysisSection = document.getElementById('analysisSection');
                const loadingIndicator = document.getElementById('loadingIndicator');
                const updateBtn = document.getElementById('updateBtn');
                const tabButtons = document.querySelectorAll('.tab-button');
                const tabContents = document.querySelectorAll('.tab-content');
                const debugInfo = document.getElementById('debugInfo');
                const showDebugCheckbox = document.getElementById('showDebug');
                const seriesSelector = document.getElementById('seriesSelector');
                const historyYears = document.getElementById('historyYears');
                const useSeasonality = document.getElementById('useSeasonality');
                const resetZoomVis = document.getElementById('resetZoomVis');
                const resetZoomForecast = document.getElementById('resetZoomForecast');
                const resetZoomNowcast = document.getElementById('resetZoomNowcast');
                const downloadForecastCSV = document.getElementById('downloadForecastCSV');
                const downloadNowcastCSV = document.getElementById('downloadNowcastCSV');
                const downloadModelCSV = document.getElementById('downloadModelCSV');
                const downloadSeasonalityCSV = document.getElementById('downloadSeasonalityCSV');
                const downloadStatus = document.getElementById('downloadStatus');
                
                // Debug logging function
                function log(message) {
                    const timestamp = new Date().toLocaleTimeString();
                    const logMessage = `[${timestamp}] ${message}`;
                    console.log(logMessage);
                    
                    if (debugInfo) {
                        debugInfo.innerHTML += logMessage + '<br>';
                        debugInfo.scrollTop = debugInfo.scrollHeight;
                    }
                }
                
                // Show/hide debug info
                showDebugCheckbox.addEventListener('change', function() {
                    debugInfo.style.display = this.checked ? 'block' : 'none';
                });
                
                // Initialize tabs
                tabButtons.forEach(button => {
                    button.addEventListener('click', () => {
                        const tabId = button.getAttribute('data-tab');
                        
                        // Update active tab button
                        tabButtons.forEach(btn => btn.classList.remove('active'));
                        button.classList.add('active');
                        
                        // Show selected tab content
                        tabContents.forEach(content => {
                            content.classList.remove('active');
                            if (content.id === tabId) {
                                content.classList.add('active');
                            }
                        });
                    });
                });
                
                // Parse date in DD/MM/YY format
                function parseDate(dateStr) {
                    try {
                        const [day, month, year] = dateStr.split('/').map(Number);
                        // Adjust for 2-digit year
                        const fullYear = year < 50 ? 2000 + year : 1900 + year;
                        return new Date(fullYear, month - 1, day);
                    } catch (error) {
                        log(`Error parsing date: ${dateStr}, error: ${error.message}`);
                        return null;
                    }
                }
                
                // Format date as DD/MM/YYYY
                function formatDate(date) {
                    const day = date.getDate().toString().padStart(2, '0');
                    const month = (date.getMonth() + 1).toString().padStart(2, '0');
                    const year = date.getFullYear();
                    return `${day}/${month}/${year}`;
                }
                
                // Calculate days since first date
                function daysSinceFirst(date, firstDate) {
                    return Math.round((date - firstDate) / (1000 * 60 * 60 * 24));
                }
                
                // Process the uploaded CSV file
                function processCSV(file) {
                    return new Promise((resolve, reject) => {
                        Papa.parse(file, {
                            header: true,
                            skipEmptyLines: true,
                            complete: function(results) {
                                if (results.errors.length > 0) {
                                    log(`CSV parsing errors: ${JSON.stringify(results.errors)}`);
                                    reject(results.errors);
                                    return;
                                }
                                
                                try {
                                    log(`CSV parsed with ${results.data.length} rows`);
                                    
                                    // Process and clean the data
                                    const data = results.data.map(row => {
                                        // Handle different possible column names
                                        const dateStr = row.Date || row.date;
                                        const attendanceType = row.Attendance_type || row.attendance_type;
                                        const serviceName = row.Service_name || row.service_name;
                                        const attendance = parseInt(row.Attendance || row.attendance);
                                        const amPm = row.AM_PM || row.am_pm;
                                        
                                        if (!dateStr || isNaN(attendance)) {
                                            log(`Skipping invalid row: ${JSON.stringify(row)}`);
                                            return null; // Skip invalid rows
                                        }
                                        
                                        const parsedDate = parseDate(dateStr);
                                        if (!parsedDate) {
                                            log(`Could not parse date: ${dateStr}`);
                                            return null;
                                        }
                                        
                                        return {
                                            date: parsedDate,
                                            dateStr: dateStr,
                                            attendanceType: attendanceType,
                                            serviceName: serviceName,
                                            attendance: attendance,
                                            amPm: amPm,
                                            month: parsedDate.getMonth() // 0-11 for Jan-Dec
                                        };
                                    }).filter(row => row !== null);
                                    
                                    // Sort by date
                                    data.sort((a, b) => a.date - b.date);
                                    
                                    log(`Processed ${data.length} valid rows`);
                                    resolve(data);
                                } catch (error) {
                                    log(`Error processing data: ${error.message}`);
                                    reject([{ message: "Error processing data: " + error.message }]);
                                }
                            },
                            error: function(error) {
                                log(`CSV parsing error: ${error.message}`);
                                reject([error]);
                            }
                        });
                    });
                }
                
                // Filter data based on history years
                function filterDataByHistory(data, yearsBack) {
                    if (yearsBack === 'all') {
                        return data;
                    }
                    
                    const years = parseInt(yearsBack);
                    const cutoffDate = new Date();
                    cutoffDate.setFullYear(cutoffDate.getFullYear() - years);
                    
                    return data.filter(d => d.date >= cutoffDate);
                }
                
                // Aggregate data based on selected view type
                function aggregateData(data, viewType) {
                    log(`Aggregating data with view type: ${viewType}`);
                    
                    // Group by date
                    const groupedByDate = {};
                    
                    data.forEach(row => {
                        const dateKey = row.date.toISOString().split('T')[0];
                        
                        if (!groupedByDate[dateKey]) {
                            groupedByDate[dateKey] = {
                                date: row.date,
                                month: row.month, // Store month for seasonality
                                total: 0,
                                am: 0,
                                pm: 0,
                                cityKids: 0,
                                sundayServices: 0
                            };
                        }
                        
                        groupedByDate[dateKey].total += row.attendance;
                        
                        if (row.amPm === 'AM') {
                            groupedByDate[dateKey].am += row.attendance;
                        } else if (row.amPm === 'PM') {
                            groupedByDate[dateKey].pm += row.attendance;
                        }
                        
                        if (row.attendanceType && row.attendanceType.includes('City Kids')) {
                            groupedByDate[dateKey].cityKids += row.attendance;
                        } else if (row.attendanceType && row.attendanceType.includes('Sunday Services')) {
                            groupedByDate[dateKey].sundayServices += row.attendance;
                        }
                    });
                    
                    // Convert to array
                    const aggregated = Object.values(groupedByDate);
                    
                    // Sort by date
                    aggregated.sort((a, b) => a.date - b.date);
                    
                    log(`Aggregated to ${aggregated.length} data points`);
                    return aggregated;
                }
                
                // Update series selector based on view type
                function updateSeriesSelector(viewType) {
                    // Clear existing options
                    seriesSelector.innerHTML = '';
                    
                    // Add options based on view type
                    if (viewType === 'total') {
                        seriesSelector.innerHTML = '<option value="total">Total Attendance</option>';
                    } else if (viewType === 'ampm') {
                        seriesSelector.innerHTML = `
                            <option value="am">AM Services</option>
                            <option value="pm">PM Services</option>
                        `;
                    } else if (viewType === 'type') {
                        seriesSelector.innerHTML = `
                            <option value="cityKids">City Kids</option>
                            <option value="sundayServices">Sunday Services</option>
                        `;
                    }
                }
                
                // Create month dummy variables for seasonality
                function createMonthDummies(data) {
                    // Create dummy variables for months (Feb-Dec, Jan is reference)
                    return data.map(d => {
                        const dummies = {};
                        // Create 11 dummies for Feb-Dec (Jan is reference month)
                        for (let i = 1; i <= 11; i++) {
                            dummies[`month${i+1}`] = d.month === i ? 1 : 0;
                        }
                        return { ...d, ...dummies };
                    });
                }
                
                // Multiple regression with seasonality
                function multipleRegression(data, xField, yField, includeSeasonality) {
                    try {
                        log(`Performing multiple regression with seasonality: ${includeSeasonality}`);
                        
                        if (data.length < 5) {
                            throw new Error("Not enough data points for regression");
                        }
                        
                        // Prepare data with month dummies if needed
                        let regressionData = data;
                        if (includeSeasonality) {
                            regressionData = createMonthDummies(data);
                        }
                        
                        // Prepare X matrix (design matrix)
                        // For each observation, we have:
                        // - Constant term (1)
                        // - Linear term (x)
                        // - Quadratic term (x^2)
                        // - Month dummies (if includeSeasonality is true)
                        const X = [];
                        const y = [];
                        
                        regressionData.forEach(d => {
                            const row = [1, d[xField], Math.pow(d[xField], 2)]; // Constant, linear, quadratic
                            
                            if (includeSeasonality) {
                                // Add month dummies (Feb-Dec)
                                for (let i = 1; i <= 11; i++) {
                                    row.push(d[`month${i+1}`]);
                                }
                            }
                            
                            X.push(row);
                            y.push(d[yField]);
                        });
                        
                        // Number of parameters
                        const numParams = X[0].length;
                        
                        // Transpose X
                        const Xt = [];
                        for (let j = 0; j < numParams; j++) {
                            const col = [];
                            for (let i = 0; i < X.length; i++) {
                                col.push(X[i][j]);
                            }
                            Xt.push(col);
                        }
                        
                        // Calculate Xt * X
                        const XtX = [];
                        for (let i = 0; i < numParams; i++) {
                            const row = [];
                            for (let j = 0; j < numParams; j++) {
                                let sum = 0;
                                for (let k = 0; k < X.length; k++) {
                                    sum += Xt[i][k] * X[k][j];
                                }
                                row.push(sum);
                            }
                            XtX.push(row);
                        }
                        
                        // Calculate Xt * y
                        const Xty = [];
                        for (let i = 0; i < numParams; i++) {
                            let sum = 0;
                            for (let j = 0; j < X.length; j++) {
                                sum += Xt[i][j] * y[j];
                            }
                            Xty.push(sum);
                        }
                        
                        // Solve the system of equations using Gaussian elimination
                        const augmentedMatrix = [];
                        for (let i = 0; i < numParams; i++) {
                            const row = [...XtX[i], Xty[i]];
                            augmentedMatrix.push(row);
                        }
                        
                        // Gaussian elimination
                        for (let i = 0; i < numParams; i++) {
                            // Find pivot
                            let maxRow = i;
                            let maxVal = Math.abs(augmentedMatrix[i][i]);
                            for (let j = i + 1; j < numParams; j++) {
                                const absVal = Math.abs(augmentedMatrix[j][i]);
                                if (absVal > maxVal) {
                                    maxRow = j;
                                    maxVal = absVal;
                                }
                            }
                            
                            // Swap rows if needed
                            if (maxRow !== i) {
                                [augmentedMatrix[i], augmentedMatrix[maxRow]] = [augmentedMatrix[maxRow], augmentedMatrix[i]];
                            }
                            
                            // Eliminate below
                            for (let j = i + 1; j < numParams; j++) {
                                const factor = augmentedMatrix[j][i] / augmentedMatrix[i][i];
                                for (let k = i; k <= numParams; k++) {
                                    augmentedMatrix[j][k] -= factor * augmentedMatrix[i][k];
                                }
                            }
                        }
                        
                        // Back substitution
                        const coefficients = new Array(numParams).fill(0);
                        for (let i = numParams - 1; i >= 0; i--) {
                            let sum = augmentedMatrix[i][numParams];
                            for (let j = i + 1; j < numParams; j++) {
                                sum -= augmentedMatrix[i][j] * coefficients[j];
                            }
                            coefficients[i] = sum / augmentedMatrix[i][i];
                        }
                        
                        // Create coefficient names
                        const coefficientNames = ['constant', 'linear', 'quadratic'];
                        if (includeSeasonality) {
                            for (let i = 1; i <= 11; i++) {
                                coefficientNames.push(`month${i+1}`);
                            }
                        }
                        
                        // Create named coefficients object
                        const namedCoefficients = {};
                        coefficients.forEach((coef, index) => {
                            namedCoefficients[coefficientNames[index]] = coef;
                        });
                        
                        // Create prediction function
                        const predict = function(x, month) {
                            let result = namedCoefficients.constant + 
                                         namedCoefficients.linear * x + 
                                         namedCoefficients.quadratic * Math.pow(x, 2);
                            
                            // Add month effect if seasonality is included and month is provided
                            if (includeSeasonality && month !== undefined && month > 0) {
                                const monthKey = `month${month+1}`;
                                if (namedCoefficients[monthKey] !== undefined && month !== 0) { // Skip January (reference month)
                                    result += namedCoefficients[monthKey];
                                }
                            }
                            
                            return result;
                        };
                        
                        // Calculate predictions and residuals
                        const predictions = [];
                        const residuals = [];
                        
                        for (let i = 0; i < regressionData.length; i++) {
                            const x = regressionData[i][xField];
                            const month = regressionData[i].month;
                            const prediction = predict(x, month);
                            predictions.push(prediction);
                            residuals.push(y[i] - prediction);
                        }
                        
                        // Calculate R-squared
                        const mean = y.reduce((sum, val) => sum + val, 0) / y.length;
                        const ssTotal = y.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0);
                        const ssResidual = residuals.reduce((sum, val) => sum + Math.pow(val, 2), 0);
                        const rSquared = 1 - (ssResidual / ssTotal);
                        
                        // Calculate adjusted R-squared
                        const n = y.length;
                        const p = numParams;
                        const adjustedRSquared = 1 - ((1 - rSquared) * (n - 1) / (n - p - 1));
                        
                        // Calculate standard error of the regression
                        const standardError = Math.sqrt(ssResidual / (n - p));
                        
                        // Generate formula string
                        let formula = `y = ${namedCoefficients.constant.toFixed(2)} + ${namedCoefficients.linear.toFixed(2)}x + ${namedCoefficients.quadratic.toFixed(2)}x²`;
                        
                        if (includeSeasonality) {
                            formula += " + monthly effects";
                        }
                        
                        log(`Regression complete. R-squared: ${rSquared.toFixed(4)}, Adjusted R-squared: ${adjustedRSquared.toFixed(4)}`);
                        
                        // Calculate monthly effects for visualization
                        const monthlyEffects = [];
                        if (includeSeasonality) {
                            // January is reference (0)
                            monthlyEffects.push({ month: 0, effect: 0, monthName: "January" });
                            
                            // February-December
                            for (let i = 1; i <= 11; i++) {
                                const monthKey = `month${i+1}`;
                                monthlyEffects.push({
                                    month: i,
                                    effect: namedCoefficients[monthKey],
                                    monthName: monthNames[i]
                                });
                            }
                        }
                        
                        return {
                            predict: predict,
                            coefficients: namedCoefficients,
                            rSquared: rSquared,
                            adjustedRSquared: adjustedRSquared,
                            standardError: standardError,
                            formula: formula,
                            includeSeasonality: includeSeasonality,
                            monthlyEffects: monthlyEffects
                        };
                    } catch (error) {
                        log(`Regression error: ${error.message}`);
                        return null;
                    }
                }
                
                // Fit model with optional seasonality
                function fitModel(data, xField, yField, includeSeasonality) {
                    try {
                        if (data.length < 5) {
                            log("Not enough data points for regression");
                            return null;
                        }
                        
                        // Use multiple regression with seasonality if requested
                        return multipleRegression(data, xField, yField, includeSeasonality);
                    } catch (error) {
                        log(`Error fitting model: ${error.message}`);
                        return null;
                    }
                }
                
                // Generate forecast data
                function generateForecast(model, data, xField, months) {
                    try {
                        if (!model || !model.predict) {
                            log("No valid model for forecast");
                            return null;
                        }
                        
                        const lastDate = data[data.length - 1].date;
                        const firstDate = data[0].date;
                        const lastX = data[data.length - 1][xField];
                        
                        log(`Generating forecast for ${months} months from ${formatDate(lastDate)}`);
                        
                        const forecastData = [];
                        const predictionIntervals = [];
                        
                        // Generate forecast for specified months
                        for (let i = 1; i <= months * 30; i += 7) { // Weekly points
                            const forecastDate = new Date(lastDate);
                            forecastDate.setDate(forecastDate.getDate() + i);
                            
                            const x = lastX + i;
                            const month = forecastDate.getMonth(); // 0-11 for seasonality
                            
                            // Use month in prediction if model includes seasonality
                            const prediction = model.includeSeasonality ? 
                                model.predict(x, month) : 
                                model.predict(x);
                            
                            // Calculate prediction interval (95%)
                            const t = 1.96; // Approximate t-value for 95% confidence
                            const se = model.standardError;
                            const interval = t * se;
                            
                            forecastData.push({
                                date: forecastDate,
                                prediction: prediction,
                                x: x,
                                month: month,
                                monthName: monthNames[month],
                                daysSinceFirst: daysSinceFirst(forecastDate, firstDate),
                                upper: prediction + interval,
                                lower: Math.max(0, prediction - interval)
                            });
                            
                            predictionIntervals.push({
                                date: forecastDate,
                                upper: prediction + interval,
                                lower: Math.max(0, prediction - interval)
                            });
                        }
                        
                        log(`Generated ${forecastData.length} forecast points`);
                        
                        return {
                            forecast: forecastData,
                            intervals: predictionIntervals
                        };
                    } catch (error) {
                        log(`Forecast error: ${error.message}`);
                        return null;
                    }
                }
                
                // Generate nowcast (predict last 6 months using data before that)
                function generateNowcast(data, xField, yField, months, includeSeasonality) {
                    try {
                        const cutoffIndex = data.length - Math.min(Math.floor(months * 30 / 7), data.length - 5);
                        
                        if (cutoffIndex < 5) {
                            log("Not enough data for nowcast");
                            return null; // Not enough data
                        }
                        
                        log(`Generating nowcast with cutoff at index ${cutoffIndex} of ${data.length}`);
                        
                        const trainingData = data.slice(0, cutoffIndex);
                        const testingData = data.slice(cutoffIndex);
                        
                        log(`Training data: ${trainingData.length} points, Testing data: ${testingData.length} points`);
                        
                        const model = fitModel(trainingData, xField, yField, includeSeasonality);
                        
                        if (!model) {
                            log("Failed to fit model for nowcast");
                            return null;
                        }
                        
                        // Generate predictions for testing period
                        const nowcastData = testingData.map(d => {
                            // Use month in prediction if model includes seasonality
                            const prediction = model.includeSeasonality ? 
                                model.predict(d[xField], d.month) : 
                                model.predict(d[xField]);
                                
                            const error = d[yField] - prediction;
                            
                            // Calculate prediction interval (95%)
                            const t = 1.96;
                            const se = model.standardError;
                            const interval = t * se;
                            
                            return {
                                date: d.date,
                                month: d.month,
                                monthName: monthNames[d.month],
                                actual: d[yField],
                                prediction: prediction,
                                error: error,
                                x: d[xField],
                                upper: prediction + interval,
                                lower: Math.max(0, prediction - interval)
                            };
                        });
                        
                        // Calculate accuracy metrics
                        const mse = nowcastData.reduce((sum, d) => sum + Math.pow(d.error, 2), 0) / nowcastData.length;
                        const rmse = Math.sqrt(mse);
                        const mae = nowcastData.reduce((sum, d) => sum + Math.abs(d.error), 0) / nowcastData.length;
                        const mape = nowcastData.reduce((sum, d) => {
                            return sum + (Math.abs(d.error) / Math.max(1, Math.abs(d.actual))) * 100;
                        }, 0) / nowcastData.length;
                        
                        log(`Nowcast metrics - RMSE: ${rmse.toFixed(2)}, MAPE: ${mape.toFixed(2)}%`);
                        
                        return {
                            model: model,
                            nowcast: nowcastData,
                            metrics: {
                                mse: mse,
                                rmse: rmse,
                                mae: mae,
                                mape: mape
                            },
                            trainingData: trainingData,
                            testingData: testingData
                        };
                    } catch (error) {
                        log(`Nowcast error: ${error.message}`);
                        return null;
                    }
                }
                
                // Create or update attendance chart
                function updateAttendanceChart(data, viewType) {
                    try {
                        const ctx = document.getElementById('attendanceChart').getContext('2d');
                        
                        // Destroy existing chart if it exists
                        if (charts.attendance) {
                            charts.attendance.destroy();
                        }
                        
                        log(`Updating attendance chart with view type: ${viewType}`);
                        
                        // Prepare datasets based on view type
                        let datasets = [];
                        
                        if (viewType === 'total') {
                            datasets = [{
                                label: 'Total Attendance',
                                data: data.map(d => ({ x: d.date, y: d.total })),
                                backgroundColor: 'rgba(54, 162, 235, 0.5)',
                                borderColor: 'rgba(54, 162, 235, 1)',
                                borderWidth: 1,
                                pointRadius: 3
                            }];
                        } else if (viewType === 'ampm') {
                            datasets = [
                                {
                                    label: 'AM Services',
                                    data: data.map(d => ({ x: d.date, y: d.am })),
                                    backgroundColor: 'rgba(255, 159, 64, 0.5)',
                                    borderColor: 'rgba(255, 159, 64, 1)',
                                    borderWidth: 1,
                                    pointRadius: 3
                                },
                                {
                                    label: 'PM Services',
                                    data: data.map(d => ({ x: d.date, y: d.pm })),
                                    backgroundColor: 'rgba(153, 102, 255, 0.5)',
                                    borderColor: 'rgba(153, 102, 255, 1)',
                                    borderWidth: 1,
                                    pointRadius: 3
                                }
                            ];
                        } else if (viewType === 'type') {
                            datasets = [
                                {
                                    label: 'City Kids',
                                    data: data.map(d => ({ x: d.date, y: d.cityKids })),
                                    backgroundColor: 'rgba(75, 192, 192, 0.5)',
                                    borderColor: 'rgba(75, 192, 192, 1)',
                                    borderWidth: 1,
                                    pointRadius: 3
                                },
                                {
                                    label: 'Sunday Services',
                                    data: data.map(d => ({ x: d.date, y: d.sundayServices })),
                                    backgroundColor: 'rgba(255, 99, 132, 0.5)',
                                    borderColor: 'rgba(255, 99, 132, 1)',
                                    borderWidth: 1,
                                    pointRadius: 3
                                }
                            ];
                        }
                        
                        // Create chart
                        charts.attendance = new Chart(ctx, {
                            type: 'scatter',
                            data: {
                                datasets: datasets
                            },
                            options: {
                                responsive: true,
                                maintainAspectRatio: false,
                                scales: {
                                    x: {
                                        type: 'time',
                                        time: {
                                            unit: 'month',
                                            displayFormats: {
                                                month: 'MMM yyyy'
                                            }
                                        },
                                        title: {
                                            display: true,
                                            text: 'Date'
                                        }
                                    },
                                    y: {
                                        beginAtZero: true,
                                        title: {
                                            display: true,
                                            text: 'Attendance'
                                        }
                                    }
                                },
                                plugins: {
                                    title: {
                                        display: true,
                                        text: 'Church Attendance Over Time'
                                    },
                                    tooltip: {
                                        callbacks: {
                                            label: function(context) {
                                                const date = new Date(context.parsed.x);
                                                return `${context.dataset.label}: ${context.parsed.y} (${formatDate(date)})`;
                                            }
                                        }
                                    },
                                    zoom: {
                                        pan: {
                                            enabled: true,
                                            mode: 'xy'
                                        },
                                        zoom: {
                                            wheel: {
                                                enabled: true,
                                            },
                                            pinch: {
                                                enabled: true
                                            },
                                            mode: 'xy'
                                        }
                                    }
                                }
                            }
                        });
                        
                        // Reset zoom button
                        resetZoomVis.addEventListener('click', () => {
                            charts.attendance.resetZoom();
                        });
                    } catch (error) {
                        log(`Error updating attendance chart: ${error.message}`);
                        uploadStatus.innerHTML = `<div class="error">Error updating chart: ${error.message}</div>`;
                    }
                }
                
                // Create or update forecast chart
                function updateForecastChart(aggregatedData, forecastData, seriesField) {
                    try {
                        const ctx = document.getElementById('forecastChart').getContext('2d');
                        
                        // Destroy existing chart if it exists
                        if (charts.forecast) {
                            charts.forecast.destroy();
                        }
                        
                        if (!forecastData) {
                            log("No forecast data available");
                            return;
                        }
                        
                        log(`Updating forecast chart with series: ${seriesField}`);
                        
                        // Determine label based on series field
                        let label = 'Total Attendance';
                        let color = 'rgba(54, 162, 235, 1)';
                        
                        if (seriesField === 'am') {
                            label = 'AM Services';
                            color = 'rgba(255, 159, 64, 1)';
                        } else if (seriesField === 'pm') {
                            label = 'PM Services';
                            color = 'rgba(153, 102, 255, 1)';
                        } else if (seriesField === 'cityKids') {
                            label = 'City Kids';
                            color = 'rgba(75, 192, 192, 1)';
                        } else if (seriesField === 'sundayServices') {
                            label = 'Sunday Services';
                            color = 'rgba(255, 99, 132, 1)';
                        }
                        
                        // Create datasets
                        const historicalData = {
                            label: `Historical ${label}`,
                            data: aggregatedData.map(d => ({ x: d.date, y: d[seriesField] })),
                            backgroundColor: `${color.slice(0, -2)}0.5)`,
                            borderColor: color,
                            borderWidth: 1,
                            pointRadius: 3,
                            type: 'scatter'
                        };
                        
                        const forecastLine = {
                            label: `Forecast ${label}`,
                            data: forecastData.forecast.map(d => ({ x: d.date, y: d.prediction })),
                            backgroundColor: 'rgba(255, 206, 86, 0.5)',
                            borderColor: 'rgba(255, 206, 86, 1)',
                            borderWidth: 2,
                            pointRadius: 0,
                            type: 'line',
                            fill: false
                        };
                        
                        const upperInterval = {
                            label: 'Upper Prediction Interval (95%)',
                            data: forecastData.forecast.map(d => ({ x: d.date, y: d.upper })),
                            backgroundColor: 'rgba(255, 206, 86, 0.2)',
                            borderColor: 'rgba(255, 206, 86, 0.5)',
                            borderWidth: 1,
                            pointRadius: 0,
                            type: 'line',
                            fill: '+1'
                        };
                        
                        const lowerInterval = {
                            label: 'Lower Prediction Interval (95%)',
                            data: forecastData.forecast.map(d => ({ x: d.date, y: d.lower })),
                            backgroundColor: 'rgba(255, 206, 86, 0.2)',
                            borderColor: 'rgba(255, 206, 86, 0.5)',
                            borderWidth: 1,
                            pointRadius: 0,
                            type: 'line',
                            fill: false
                        };
                        
                        // Create chart
                        charts.forecast = new Chart(ctx, {
                            type: 'scatter',
                            data: {
                                datasets: [historicalData, forecastLine, upperInterval, lowerInterval]
                            },
                            options: {
                                responsive: true,
                                maintainAspectRatio: false,
                                scales: {
                                    x: {
                                        type: 'time',
                                        time: {
                                            unit: 'month',
                                            displayFormats: {
                                                month: 'MMM yyyy'
                                            }
                                        },
                                        title: {
                                            display: true,
                                            text: 'Date'
                                        }
                                    },
                                    y: {
                                        beginAtZero: true,
                                        title: {
                                            display: true,
                                            text: 'Attendance'
                                        }
                                    }
                                },
                                plugins: {
                                    title: {
                                        display: true,
                                        text: `${label} Forecast`
                                    },
                                    tooltip: {
                                        callbacks: {
                                            label: function(context) {
                                                const date = new Date(context.parsed.x);
                                                return `${context.dataset.label}: ${Math.round(context.parsed.y)} (${formatDate(date)})`;
                                            }
                                        }
                                    },
                                    zoom: {
                                        pan: {
                                            enabled: true,
                                            mode: 'xy'
                                        },
                                        zoom: {
                                            wheel: {
                                                enabled: true,
                                            },
                                            pinch: {
                                                enabled: true
                                            },
                                            mode: 'xy'
                                        }
                                    }
                                }
                            }
                        });
                        
                        // Reset zoom button
                        resetZoomForecast.addEventListener('click', () => {
                            charts.forecast.resetZoom();
                        });
                        
                        // Store forecast results for CSV export
                        forecastResults = {
                            model: models.current,
                            data: forecastData.forecast,
                            label: label
                        };
                        
                        // Display forecast results
                        const forecastResultsDiv = document.getElementById('forecastResults');
                        
                        let resultsHTML = `<p>Model: ${models.current.formula}</p>`;
                        resultsHTML += `<p>R-squared: ${models.current.rSquared.toFixed(4)}</p>`;
                        resultsHTML += `<p>Adjusted R-squared: ${models.current.adjustedRSquared.toFixed(4)}</p>`;
                        
                        resultsHTML += `<table>
                            <tr>
                                <th>Date</th>
                                <th>Month</th>
                                <th>Forecast</th>
                                <th>95% Prediction Interval</th>
                            </tr>`;
                        
                        // Show all forecast points
                        forecastData.forecast.forEach((forecast, index) => {
                            // Only show weekly points to avoid overwhelming the table
                            if (index % 4 === 0) {
                                resultsHTML += `<tr>
                                    <td>${formatDate(forecast.date)}</td>
                                    <td>${forecast.monthName}</td>
                                    <td>${Math.round(forecast.prediction)}</td>
                                    <td>${Math.round(forecast.lower)} - ${Math.round(forecast.upper)}</td>
                                </tr>`;
                            }
                        });
                        
                        resultsHTML += `</table>`;
                        forecastResultsDiv.innerHTML = resultsHTML;
                    } catch (error) {
                        log(`Error updating forecast chart: ${error.message}`);
                        uploadStatus.innerHTML = `<div class="error">Error updating forecast chart: ${error.message}</div>`;
                    }
                }
                
                // Create or update nowcast chart
                function updateNowcastChart(nowcastData, seriesField) {
                    try {
                        const ctx = document.getElementById('nowcastChart').getContext('2d');
                        
                        // Destroy existing chart if it exists
                        if (charts.nowcast) {
                            charts.nowcast.destroy();
                        }
                        
                        if (!nowcastData) {
                            log("No nowcast data available");
                            return;
                        }
                        
                        log(`Updating nowcast chart with series: ${seriesField}`);
                        
                        // Determine label based on series field
                        let label = 'Total Attendance';
                        let color = 'rgba(54, 162, 235, 1)';
                        
                        if (seriesField === 'am') {
                            label = 'AM Services';
                            color = 'rgba(255, 159, 64, 1)';
                        } else if (seriesField === 'pm') {
                            label = 'PM Services';
                            color = 'rgba(153, 102, 255, 1)';
                        } else if (seriesField === 'cityKids') {
                            label = 'City Kids';
                            color = 'rgba(75, 192, 192, 1)';
                        } else if (seriesField === 'sundayServices') {
                            label = 'Sunday Services';
                            color = 'rgba(255, 99, 132, 1)';
                        }
                        
                        // Create datasets
                        const trainingData = {
                            label: `Training Data`,
                            data: nowcastData.trainingData.map(d => ({ x: d.date, y: d[seriesField] })),
                            backgroundColor: `${color.slice(0, -2)}0.5)`,
                            borderColor: color,
                            borderWidth: 1,
                            pointRadius: 3,
                            type: 'scatter'
                        };
                        
                        const actualData = {
                            label: `Actual ${label}`,
                            data: nowcastData.nowcast.map(d => ({ x: d.date, y: d.actual })),
                            backgroundColor: 'rgba(75, 192, 192, 0.5)',
                            borderColor: 'rgba(75, 192, 192, 1)',
                            borderWidth: 1,
                            pointRadius: 4,
                            type: 'scatter'
                        };
                        
                        const predictedData = {
                            label: `Predicted ${label}`,
                            data: nowcastData.nowcast.map(d => ({ x: d.date, y: d.prediction })),
                            backgroundColor: 'rgba(255, 206, 86, 0.5)',
                            borderColor: 'rgba(255, 206, 86, 1)',
                            borderWidth: 2,
                            pointRadius: 0,
                            type: 'line',
                            fill: false
                        };
                        
                        const upperInterval = {
                            label: 'Upper Prediction Interval (95%)',
                            data: nowcastData.nowcast.map(d => ({ x: d.date, y: d.upper })),
                            backgroundColor: 'rgba(255, 206, 86, 0.2)',
                            borderColor: 'rgba(255, 206, 86, 0.5)',
                            borderWidth: 1,
                            pointRadius: 0,
                            type: 'line',
                            fill: '+1'
                        };
                        
                        const lowerInterval = {
                            label: 'Lower Prediction Interval (95%)',
                            data: nowcastData.nowcast.map(d => ({ x: d.date, y: d.lower })),
                            backgroundColor: 'rgba(255, 206, 86, 0.2)',
                            borderColor: 'rgba(255, 206, 86, 0.5)',
                            borderWidth: 1,
                            pointRadius: 0,
                            type: 'line',
                            fill: false
                        };
                        
                        // Create chart
                        charts.nowcast = new Chart(ctx, {
                            type: 'scatter',
                            data: {
                                datasets: [trainingData, actualData, predictedData, upperInterval, lowerInterval]
                            },
                            options: {
                                responsive: true,
                                maintainAspectRatio: false,
                                scales: {
                                    x: {
                                        type: 'time',
                                        time: {
                                            unit: 'month',
                                            displayFormats: {
                                                month: 'MMM yyyy'
                                            }
                                        },
                                        title: {
                                            display: true,
                                            text: 'Date'
                                        }
                                    },
                                    y: {
                                        beginAtZero: true,
                                        title: {
                                            display: true,
                                            text: 'Attendance'
                                        }
                                    }
                                },
                                plugins: {
                                    title: {
                                        display: true,
                                        text: `${label} Nowcast`
                                    },
                                    tooltip: {
                                        callbacks: {
                                            label: function(context) {
                                                const date = new Date(context.parsed.x);
                                                return `${context.dataset.label}: ${Math.round(context.parsed.y)} (${formatDate(date)})`;
                                            }
                                        }
                                    },
                                    zoom: {
                                        pan: {
                                            enabled: true,
                                            mode: 'xy'
                                        },
                                        zoom: {
                                            wheel: {
                                                enabled: true,
                                            },
                                            pinch: {
                                                enabled: true
                                            },
                                            mode: 'xy'
                                        }
                                    }
                                }
                            }
                        });
                        
                        // Reset zoom button
                        resetZoomNowcast.addEventListener('click', () => {
                            charts.nowcast.resetZoom();
                        });
                        
                        // Store nowcast results for CSV export
                        nowcastResults = {
                            model: nowcastData.model,
                            data: nowcastData.nowcast,
                            metrics: nowcastData.metrics,
                            label: label
                        };
                        
                        // Display nowcast results
                        const nowcastResultsDiv = document.getElementById('nowcastResults');
                        
                        let resultsHTML = `<p>Model: ${nowcastData.model.formula}</p>`;
                        resultsHTML += `<p>R-squared: ${nowcastData.model.rSquared.toFixed(4)}</p>`;
                        resultsHTML += `<p>Adjusted R-squared: ${nowcastData.model.adjustedRSquared.toFixed(4)}</p>`;
                        resultsHTML += `<p>Nowcast Metrics:</p>`;
                        resultsHTML += `<ul>
                            <li>Mean Squared Error (MSE): ${nowcastData.metrics.mse.toFixed(2)}</li>
                            <li>Root Mean Squared Error (RMSE): ${nowcastData.metrics.rmse.toFixed(2)}</li>
                            <li>Mean Absolute Error (MAE): ${nowcastData.metrics.mae.toFixed(2)}</li>
                            <li>Mean Absolute Percentage Error (MAPE): ${nowcastData.metrics.mape.toFixed(2)}%</li>
                        </ul>`;
                        
                        resultsHTML += `<table>
                            <tr>
                                <th>Date</th>
                                <th>Month</th>
                                <th>Actual</th>
                                <th>Predicted</th>
                                <th>Error</th>
                                <th>95% Prediction Interval</th>
                            </tr>`;
                        
                        nowcastData.nowcast.forEach(d => {
                            resultsHTML += `<tr>
                                <td>${formatDate(d.date)}</td>
                                <td>${d.monthName}</td>
                                <td>${Math.round(d.actual)}</td>
                                <td>${Math.round(d.prediction)}</td>
                                <td>${Math.round(d.error)} (${(d.error / Math.max(1, d.actual) * 100).toFixed(1)}%)</td>
                                <td>${Math.round(d.lower)} - ${Math.round(d.upper)}</td>
                            </tr>`;
                        });
                        
                        resultsHTML += `</table>`;
                        nowcastResultsDiv.innerHTML = resultsHTML;
                    } catch (error) {
                        log(`Error updating nowcast chart: ${error.message}`);
                        uploadStatus.innerHTML = `<div class="error">Error updating nowcast chart: ${error.message}</div>`;
                    }
                }
                
                // Create or update seasonality chart
                function updateSeasonalityChart(model) {
                    try {
                        const ctx = document.getElementById('seasonalityChart').getContext('2d');
                        
                        // Destroy existing chart if it exists
                        if (charts.seasonality) {
                            charts.seasonality.destroy();
                        }
                        
                        if (!model || !model.includeSeasonality || !model.monthlyEffects || model.monthlyEffects.length === 0) {
                            document.getElementById('seasonalityDetails').innerHTML = '<p>No seasonality data available. Enable monthly seasonality in the options.</p>';
                            return;
                        }
                        
                        log(`Updating seasonality chart`);
                        
                        // Prepare data for chart
                        const labels = model.monthlyEffects.map(m => m.monthName);
                        const data = model.monthlyEffects.map(m => m.effect);
                        
                        // Find min and max for better visualization
                        const maxEffect = Math.max(...data);
                        const minEffect = Math.min(...data);
                        const absMax = Math.max(Math.abs(maxEffect), Math.abs(minEffect));
                        
                        // Create chart
                        charts.seasonality = new Chart(ctx, {
                            type: 'bar',
                            data: {
                                labels: labels,
                                datasets: [{
                                    label: 'Monthly Effect',
                                    data: data,
                                    backgroundColor: data.map(d => d >= 0 ? 'rgba(75, 192, 192, 0.5)' : 'rgba(255, 99, 132, 0.5)'),
                                    borderColor: data.map(d => d >= 0 ? 'rgba(75, 192, 192, 1)' : 'rgba(255, 99, 132, 1)'),
                                    borderWidth: 1
                                }]
                            },
                            options: {
                                responsive: true,
                                maintainAspectRatio: false,
                                scales: {
                                    y: {
                                        beginAtZero: true,
                                        title: {
                                            display: true,
                                            text: 'Effect on Attendance'
                                        },
                                        suggestedMin: -absMax * 1.1,
                                        suggestedMax: absMax * 1.1
                                    },
                                    x: {
                                        title: {
                                            display: true,
                                            text: 'Month'
                                        }
                                    }
                                },
                                plugins: {
                                    title: {
                                        display: true,
                                        text: 'Monthly Seasonality Effects'
                                    },
                                    tooltip: {
                                        callbacks: {
                                            label: function(context) {
                                                const value = context.raw;
                                                return `Effect: ${value.toFixed(2)}`;
                                            }
                                        }
                                    }
                                }
                            }
                        });
                        
                        // Store seasonality results for CSV export
                        seasonalityResults = {
                            monthlyEffects: model.monthlyEffects
                        };
                        
                        // Display seasonality details
                        const seasonalityDetails = document.getElementById('seasonalityDetails');
                        
                        let detailsHTML = `<p>Monthly effects relative to January (reference month):</p>`;
                        detailsHTML += `<table>
                            <tr>
                                <th>Month</th>
                                <th>Effect</th>
                                <th>Interpretation</th>
                            </tr>`;
                        
                        model.monthlyEffects.forEach(m => {
                            const effect = m.effect;
                            let interpretation = '';
                            
                            if (m.month === 0) {
                                interpretation = 'Reference month';
                            } else if (effect > 0) {
                                interpretation = `${effect.toFixed(2)} higher than January`;
                            } else if (effect < 0) {
                                interpretation = `${Math.abs(effect).toFixed(2)} lower than January`;
                            } else {
                                interpretation = 'Same as January';
                            }
                            
                            detailsHTML += `<tr>
                                <td>${m.monthName}</td>
                                <td>${effect.toFixed(2)}</td>
                                <td>${interpretation}</td>
                            </tr>`;
                        });
                        
                        detailsHTML += `</table>`;
                        
                        // Add interpretation
                        detailsHTML += `<h4>Interpretation</h4>`;
                        detailsHTML += `<p>The chart and table above show the seasonal effect of each month on attendance, relative to January (which is used as the reference month).</p>`;
                        
                        // Find highest and lowest months
                        const sortedEffects = [...model.monthlyEffects].sort((a, b) => b.effect - a.effect);
                        const highestMonth = sortedEffects[0];
                        const lowestMonth = sortedEffects[sortedEffects.length - 1];
                        
                        if (highestMonth.month !== 0) {
                            detailsHTML += `<p>The highest attendance tends to be in <strong>${highestMonth.monthName}</strong>, which is on average <strong>${highestMonth.effect.toFixed(2)}</strong> higher than January.</p>`;
                        }
                        
                        if (lowestMonth.month !== 0) {
                            detailsHTML += `<p>The lowest attendance tends to be in <strong>${lowestMonth.monthName}</strong>, which is on average <strong>${Math.abs(lowestMonth.effect).toFixed(2)}</strong> lower than January.</p>`;
                        }
                        
                        seasonalityDetails.innerHTML = detailsHTML;
                    } catch (error) {
                        log(`Error updating seasonality chart: ${error.message}`);
                        document.getElementById('seasonalityDetails').innerHTML = `<div class="error">Error updating seasonality chart: ${error.message}</div>`;
                    }
                }
                
                // Display model details
                function displayModelDetails(model) {
                    try {
                        if (!model) {
                            log("No model available for details");
                            return;
                        }
                        
                        log("Displaying model details");
                        
                        const modelDetails = document.getElementById('modelDetails');
                        
                        let detailsHTML = `<p>Regression Model: ${model.formula}</p>`;
                        detailsHTML += `<p>Model Statistics:</p>`;
                        detailsHTML += `<ul>
                            <li>R-squared: ${model.rSquared.toFixed(4)}</li>
                            <li>Adjusted R-squared: ${model.adjustedRSquared.toFixed(4)}</li>
                            <li>Standard Error: ${model.standardError.toFixed(4)}</li>
                        </ul>`;
                        
                        detailsHTML += `<p>Coefficients:</p>`;
                        detailsHTML += `<div class="coefficient-table">`;
                        detailsHTML += `<table>
                            <tr>
                                <th>Parameter</th>
                                <th>Coefficient</th>
                            </tr>
                            <tr>
                                <td>Constant</td>
                                <td>${model.coefficients.constant.toFixed(4)}</td>
                            </tr>
                            <tr>
                                <td>Linear term</td>
                                <td>${model.coefficients.linear.toFixed(4)}</td>
                            </tr>
                            <tr>
                                <td>Quadratic term</td>
                                <td>${model.coefficients.quadratic.toFixed(4)}</td>
                            </tr>`;
                        
                        // Add monthly coefficients if seasonality is included
                        if (model.includeSeasonality) {
                            for (let i = 1; i <= 11; i++) {
                                const monthKey = `month${i+1}`;
                                if (model.coefficients[monthKey] !== undefined) {
                                    detailsHTML += `<tr>
                                        <td>${monthNames[i]} (vs. January)</td>
                                        <td>${model.coefficients[monthKey].toFixed(4)}</td>
                                    </tr>`;
                                }
                            }
                        }
                        
                        detailsHTML += `</table>`;
                        detailsHTML += `</div>`;
                        
                        detailsHTML += `<p>Interpretation:</p>`;
                        detailsHTML += `<ul>`;
                        
                        if (model.coefficients.quadratic > 0) {
                            detailsHTML += `<li>The positive quadratic term (${model.coefficients.quadratic.toFixed(4)}) indicates an accelerating growth in attendance over time.</li>`;
                        } else if (model.coefficients.quadratic < 0) {
                            detailsHTML += `<li>The negative quadratic term (${model.coefficients.quadratic.toFixed(4)}) indicates a decelerating or declining trend in attendance over time.</li>`;
                        } else {
                            detailsHTML += `<li>The quadratic term is close to zero, suggesting a more linear trend in attendance.</li>`;
                        }
                        
                        if (model.coefficients.linear > 0) {
                            detailsHTML += `<li>The positive linear term (${model.coefficients.linear.toFixed(4)}) indicates an overall increasing trend.</li>`;
                        } else if (model.coefficients.linear < 0) {
                            detailsHTML += `<li>The negative linear term (${model.coefficients.linear.toFixed(4)}) indicates an overall decreasing trend.</li>`;
                        }
                        
                        detailsHTML += `<li>The R-squared value of ${model.rSquared.toFixed(4)} indicates that the model explains ${(model.rSquared * 100).toFixed(1)}% of the variance in attendance.</li>`;
                        
                        if (model.includeSeasonality) {
                            detailsHTML += `<li>The model includes monthly seasonality effects, with January as the reference month.</li>`;
                        }
                        
                        detailsHTML += `</ul>`;
                        
                        modelDetails.innerHTML = detailsHTML;
                    } catch (error) {
                        log(`Error displaying model details: ${error.message}`);
                        uploadStatus.innerHTML = `<div class="error">Error displaying model details: ${error.message}</div>`;
                    }
                }
                
                // Generate CSV content
                function generateCSV(data, headers) {
                    try {
                        log(`Generating CSV with ${data.length} rows and ${headers.length} columns`);
                        let csvContent = headers.join(',') + '\n';
                        
                        data.forEach(row => {
                            const values = headers.map(header => {
                                if (header === 'date') {
                                    return formatDate(row.date);
                                }
                                // Handle null or undefined values
                                return row[header] !== undefined && row[header] !== null ? row[header] : '';
                            });
                            csvContent += values.join(',') + '\n';
                        });
                        
                        return csvContent;
                    } catch (error) {
                        log(`Error generating CSV: ${error.message}`);
                        throw error;
                    }
                }
                
                // Download CSV file - Fixed version
                function downloadCSV(content, filename) {
                    try {
                        log(`Preparing to download CSV: ${filename} (${content.length} bytes)`);
                        
                        // Create a Blob with the CSV content
                        const blob = new Blob([content], { type: 'text/csv;charset=utf-8;' });
                        
                        // Create a download link
                        const link = document.createElement('a');
                        
                        // Use createObjectURL to create a URL for the blob
                        const url = URL.createObjectURL(blob);
                        log(`Created blob URL: ${url}`);
                        
                        // Set link attributes
                        link.setAttribute('href', url);
                        link.setAttribute('download', filename);
                        link.style.display = 'none';
                        
                        // Add link to document, click it, and remove it
                        document.body.appendChild(link);
                        
                        // Show download status
                        if (downloadStatus) {
                            downloadStatus.textContent = `Downloading ${filename}...`;
                        }
                        
                        // Use setTimeout to ensure the UI updates before download starts
                        setTimeout(() => {
                            try {
                                log(`Triggering download for ${filename}`);
                                link.click();
                                
                                // Clean up
                                setTimeout(() => {
                                    document.body.removeChild(link);
                                    URL.revokeObjectURL(url);
                                    
                                    if (downloadStatus) {
                                        downloadStatus.textContent = `Download complete: ${filename}`;
                                        
                                        // Clear status after a few seconds
                                        setTimeout(() => {
                                            downloadStatus.textContent = '';
                                        }, 3000);
                                    }
                                    
                                    log(`Download triggered for ${filename}`);
                                }, 100);
                            } catch (clickError) {
                                log(`Error during download click: ${clickError.message}`);
                                if (downloadStatus) {
                                    downloadStatus.textContent = `Download failed: ${clickError.message}`;
                                }
                            }
                        }, 100);
                    } catch (error) {
                        log(`Download error: ${error.message}`);
                        if (downloadStatus) {
                            downloadStatus.textContent = `Download failed: ${error.message}`;
                        }
                        alert(`Failed to download file: ${error.message}`);
                    }
                }
                
                // Perform full analysis
                function performAnalysis() {
                    try {
                        log("Starting analysis");
                        loadingIndicator.style.display = 'block';
                        
                        // Get selected options
                        const viewType = document.querySelector('input[name="viewType"]:checked').value;
                        const seriesField = document.getElementById('seriesSelector').value;
                        const historyYearsValue = document.getElementById('historyYears').value;
                        const forecastMonths = parseInt(document.getElementById('forecastMonths').value);
                        const nowcastMonths = parseInt(document.getElementById('nowcastMonths').value);
                        const includeSeasonality = document.getElementById('useSeasonality').checked;
                        
                        log(`Analysis parameters - View: ${viewType}, Series: ${seriesField}, History: ${historyYearsValue}, Forecast: ${forecastMonths} months, Nowcast: ${nowcastMonths} months, Seasonality: ${includeSeasonality}`);
                        
                        // Filter data by history years
                        const filteredData = filterDataByHistory(attendanceData, historyYearsValue);
                        
                        // Aggregate data
                        aggregatedData = aggregateData(filteredData, viewType);
                        
                        // Add days since first date
                        const firstDate = aggregatedData[0].date;
                        aggregatedData.forEach(d => {
                            d.daysSinceFirst = daysSinceFirst(d.date, firstDate);
                        });
                        
                        log(`Fitting model with seriesField: ${seriesField}, seasonality: ${includeSeasonality}`);
                        const model = fitModel(aggregatedData, 'daysSinceFirst', seriesField, includeSeasonality);
                        models.current = model;
                        
                        if (!model) {
                            uploadStatus.innerHTML = `<div class="error">Failed to fit model to the data. Please check your data or try a different view.</div>`;
                            loadingIndicator.style.display = 'none';
                            return;
                        }
                        
                        // Generate forecast
                        const forecastData = generateForecast(model, aggregatedData, 'daysSinceFirst', forecastMonths);
                        
                        // Generate nowcast
                        const nowcastData = generateNowcast(aggregatedData, 'daysSinceFirst', seriesField, nowcastMonths, includeSeasonality);
                        
                        // Update charts
                        updateAttendanceChart(aggregatedData, viewType);
                        updateForecastChart(aggregatedData, forecastData, seriesField);
                        updateNowcastChart(nowcastData, seriesField);
                        displayModelDetails(model);
                        updateSeasonalityChart(model);
                        
                        log("Analysis complete");
                        loadingIndicator.style.display = 'none';
                    } catch (error) {
                        log(`Analysis error: ${error.message}`);
                        uploadStatus.innerHTML = `<div class="error">Error performing analysis: ${error.message}</div>`;
                        loadingIndicator.style.display = 'none';
                    }
                }
                
                // Handle file upload
                uploadBtn.addEventListener('click', async function() {
                    try {
                        log("Upload button clicked");
                        const file = csvFileInput.files[0];
                        
                        if (!file) {
                            uploadStatus.innerHTML = '<div class="error">Please select a CSV file to upload.</div>';
                            return;
                        }
                        
                        loadingIndicator.style.display = 'block';
                        uploadStatus.innerHTML = '<div class="success">Processing file...</div>';
                        
                        log(`Processing file: ${file.name}, size: ${file.size} bytes`);
                        
                        // Process the CSV file
                        attendanceData = await processCSV(file);
                        
                        if (attendanceData.length === 0) {
                            uploadStatus.innerHTML = '<div class="error">No valid data found in the CSV file.</div>';
                            loadingIndicator.style.display = 'none';
                            return;
                        }
                        
                        uploadStatus.innerHTML = `<div class="success">Successfully processed ${attendanceData.length} attendance records.</div>`;
                        analysisSection.style.display = 'block';
                        
                        // Perform initial analysis
                        performAnalysis();
                    } catch (errors) {
                        log(`Upload errors: ${JSON.stringify(errors)}`);
                        let errorMessage = 'Error processing file: ';
                        
                        if (Array.isArray(errors)) {
                            errorMessage += errors.map(e => e.message || e).join(', ');
                        } else {
                            errorMessage += errors.message || errors;
                        }
                        
                        uploadStatus.innerHTML = `<div class="error">${errorMessage}</div>`;
                        loadingIndicator.style.display = 'none';
                    }
                });
                
                // Handle update button
                updateBtn.addEventListener('click', function() {
                    log("Update button clicked");
                    performAnalysis();
                });
                
                // Handle view type changes
                document.querySelectorAll('input[name="viewType"]').forEach(radio => {
                    radio.addEventListener('change', function() {
                        log(`View type changed to: ${this.value}`);
                        updateSeriesSelector(this.value);
                        performAnalysis();
                    });
                });
                
                // Handle download forecast CSV
                downloadForecastCSV.addEventListener('click', function() {
                    try {
                        log("Download forecast CSV button clicked");
                        if (forecastResults && forecastResults.data && forecastResults.data.length > 0) {
                            const headers = ['date', 'monthName', 'prediction', 'lower', 'upper'];
                            const csvContent = generateCSV(forecastResults.data, headers);
                            downloadCSV(csvContent, `${forecastResults.label}_forecast.csv`);
                        } else {
                            log("No forecast data available to download");
                            alert('No forecast data available to download');
                        }
                    } catch (error) {
                        log(`Error downloading forecast CSV: ${error.message}`);
                        alert(`Error downloading forecast CSV: ${error.message}`);
                    }
                });
                
                // Handle download nowcast CSV
                downloadNowcastCSV.addEventListener('click', function() {
                    try {
                        log("Download nowcast CSV button clicked");
                        if (nowcastResults && nowcastResults.data && nowcastResults.data.length > 0) {
                            const headers = ['date', 'monthName', 'actual', 'prediction', 'error', 'lower', 'upper'];
                            const csvContent = generateCSV(nowcastResults.data, headers);
                            downloadCSV(csvContent, `${nowcastResults.label}_nowcast.csv`);
                        } else {
                            log("No nowcast data available to download");
                            alert('No nowcast data available to download');
                        }
                    } catch (error) {
                        log(`Error downloading nowcast CSV: ${error.message}`);
                        alert(`Error downloading nowcast CSV: ${error.message}`);
                    }
                });
                
                // Handle download model CSV
                downloadModelCSV.addEventListener('click', function() {
                    try {
                        log("Download model CSV button clicked");
                        if (models.current) {
                            // Create array of objects for the CSV
                            const modelData = [];
                            
                            // Add all coefficients
                            Object.entries(models.current.coefficients).forEach(([key, value]) => {
                                modelData.push({
                                    parameter: key,
                                    value: value
                                });
                            });
                            
                            // Add model statistics
                            modelData.push({ parameter: 'r_squared', value: models.current.rSquared });
                            modelData.push({ parameter: 'adjusted_r_squared', value: models.current.adjustedRSquared });
                            modelData.push({ parameter: 'standard_error', value: models.current.standardError });
                            
                            const headers = ['parameter', 'value'];
                            const csvContent = generateCSV(modelData, headers);
                            downloadCSV(csvContent, 'model_details.csv');
                        } else {
                            log("No model data available to download");
                            alert('No model data available to download');
                        }
                    } catch (error) {
                        log(`Error downloading model CSV: ${error.message}`);
                        alert(`Error downloading model CSV: ${error.message}`);
                    }
                });
                
                // Handle download seasonality CSV
                downloadSeasonalityCSV.addEventListener('click', function() {
                    try {
                        log("Download seasonality CSV button clicked");
                        if (seasonalityResults && seasonalityResults.monthlyEffects) {
                            const headers = ['month', 'monthName', 'effect'];
                            const csvContent = generateCSV(seasonalityResults.monthlyEffects, headers);
                            downloadCSV(csvContent, 'monthly_seasonality.csv');
                        } else {
                            log("No seasonality data available to download");
                            alert('No seasonality data available to download');
                        }
                    } catch (error) {
                        log(`Error downloading seasonality CSV: ${error.message}`);
                        alert(`Error downloading seasonality CSV: ${error.message}`);
                    }
                });
                
                log("Interface ready");
            } catch (error) {
                console.error('Initialization error:', error);
                document.body.innerHTML += `<div class="error">Interface initialization failed: ${error.message}</div>`;
            }
        })();
    </script>
</body>
</html>
